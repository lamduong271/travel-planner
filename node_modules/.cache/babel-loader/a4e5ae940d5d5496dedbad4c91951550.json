{"ast":null,"code":"import { call, put, select, takeLatest, delay } from 'redux-saga/effects';\nimport { request } from 'utils/request';\nimport { selectUsername } from './selectors';\nimport { githubRepoFormActions as actions } from '.';\nimport { RepoErrorType } from './types';\n/**\n * Github repos request/response handler\n */\n\nexport function* getRepos() {\n  yield delay(500); // Select username from store\n\n  const username = yield select(selectUsername);\n\n  if (username.length === 0) {\n    yield put(actions.repoError(RepoErrorType.USERNAME_EMPTY));\n    return;\n  }\n\n  const requestURL = `https://api.github.com/users/${username}/repos?type=all&sort=updated`;\n\n  try {\n    // Call our request helper (see 'utils/request')\n    const repos = yield call(request, requestURL);\n\n    if ((repos === null || repos === void 0 ? void 0 : repos.length) > 0) {\n      yield put(actions.reposLoaded(repos));\n    } else {\n      yield put(actions.repoError(RepoErrorType.USER_HAS_NO_REPO));\n    }\n  } catch (err) {\n    var _err$response;\n\n    if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) === 404) {\n      yield put(actions.repoError(RepoErrorType.USER_NOT_FOUND));\n    } else if (err.message === 'Failed to fetch') {\n      yield put(actions.repoError(RepoErrorType.GITHUB_RATE_LIMIT));\n    } else {\n      yield put(actions.repoError(RepoErrorType.RESPONSE_ERROR));\n    }\n  }\n}\n/**\n * Root saga manages watcher lifecycle\n */\n\nexport function* githubRepoFormSaga() {\n  // Watches for loadRepos actions and calls getRepos when one comes in.\n  // By using `takeLatest` only the result of the latest API call is applied.\n  // It returns task descriptor (just like fork) so we can continue execution\n  // It will be cancelled automatically on component unmount\n  yield takeLatest(actions.loadRepos.type, getRepos);\n}","map":{"version":3,"sources":["/Users/lamduong/Planner/TripPlanner/TripPlanner/src/app/pages/HomePage/Features/GithubRepoForm/slice/saga.ts"],"names":["call","put","select","takeLatest","delay","request","selectUsername","githubRepoFormActions","actions","RepoErrorType","getRepos","username","length","repoError","USERNAME_EMPTY","requestURL","repos","reposLoaded","USER_HAS_NO_REPO","err","response","status","USER_NOT_FOUND","message","GITHUB_RATE_LIMIT","RESPONSE_ERROR","githubRepoFormSaga","loadRepos","type"],"mappings":"AAAA,SAASA,IAAT,EAAeC,GAAf,EAAoBC,MAApB,EAA4BC,UAA5B,EAAwCC,KAAxC,QAAqD,oBAArD;AACA,SAASC,OAAT,QAAwB,eAAxB;AACA,SAASC,cAAT,QAA+B,aAA/B;AACA,SAASC,qBAAqB,IAAIC,OAAlC,QAAiD,GAAjD;AAEA,SAASC,aAAT,QAA8B,SAA9B;AAEA;AACA;AACA;;AACA,OAAO,UAAUC,QAAV,GAAqB;AAC1B,QAAMN,KAAK,CAAC,GAAD,CAAX,CAD0B,CAE1B;;AACA,QAAMO,QAAgB,GAAG,MAAMT,MAAM,CAACI,cAAD,CAArC;;AACA,MAAIK,QAAQ,CAACC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,UAAMX,GAAG,CAACO,OAAO,CAACK,SAAR,CAAkBJ,aAAa,CAACK,cAAhC,CAAD,CAAT;AACA;AACD;;AACD,QAAMC,UAAU,GAAI,gCAA+BJ,QAAS,8BAA5D;;AAEA,MAAI;AACF;AACA,UAAMK,KAAa,GAAG,MAAMhB,IAAI,CAACK,OAAD,EAAUU,UAAV,CAAhC;;AACA,QAAI,CAAAC,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEJ,MAAP,IAAgB,CAApB,EAAuB;AACrB,YAAMX,GAAG,CAACO,OAAO,CAACS,WAAR,CAAoBD,KAApB,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAMf,GAAG,CAACO,OAAO,CAACK,SAAR,CAAkBJ,aAAa,CAACS,gBAAhC,CAAD,CAAT;AACD;AACF,GARD,CAQE,OAAOC,GAAP,EAAiB;AAAA;;AACjB,QAAI,kBAAAA,GAAG,CAACC,QAAJ,gEAAcC,MAAd,MAAyB,GAA7B,EAAkC;AAChC,YAAMpB,GAAG,CAACO,OAAO,CAACK,SAAR,CAAkBJ,aAAa,CAACa,cAAhC,CAAD,CAAT;AACD,KAFD,MAEO,IAAIH,GAAG,CAACI,OAAJ,KAAgB,iBAApB,EAAuC;AAC5C,YAAMtB,GAAG,CAACO,OAAO,CAACK,SAAR,CAAkBJ,aAAa,CAACe,iBAAhC,CAAD,CAAT;AACD,KAFM,MAEA;AACL,YAAMvB,GAAG,CAACO,OAAO,CAACK,SAAR,CAAkBJ,aAAa,CAACgB,cAAhC,CAAD,CAAT;AACD;AACF;AACF;AAED;AACA;AACA;;AACA,OAAO,UAAUC,kBAAV,GAA+B;AACpC;AACA;AACA;AACA;AACA,QAAMvB,UAAU,CAACK,OAAO,CAACmB,SAAR,CAAkBC,IAAnB,EAAyBlB,QAAzB,CAAhB;AACD","sourcesContent":["import { call, put, select, takeLatest, delay } from 'redux-saga/effects';\nimport { request } from 'utils/request';\nimport { selectUsername } from './selectors';\nimport { githubRepoFormActions as actions } from '.';\nimport { Repo } from 'types/Repo';\nimport { RepoErrorType } from './types';\n\n/**\n * Github repos request/response handler\n */\nexport function* getRepos() {\n  yield delay(500);\n  // Select username from store\n  const username: string = yield select(selectUsername);\n  if (username.length === 0) {\n    yield put(actions.repoError(RepoErrorType.USERNAME_EMPTY));\n    return;\n  }\n  const requestURL = `https://api.github.com/users/${username}/repos?type=all&sort=updated`;\n\n  try {\n    // Call our request helper (see 'utils/request')\n    const repos: Repo[] = yield call(request, requestURL);\n    if (repos?.length > 0) {\n      yield put(actions.reposLoaded(repos));\n    } else {\n      yield put(actions.repoError(RepoErrorType.USER_HAS_NO_REPO));\n    }\n  } catch (err: any) {\n    if (err.response?.status === 404) {\n      yield put(actions.repoError(RepoErrorType.USER_NOT_FOUND));\n    } else if (err.message === 'Failed to fetch') {\n      yield put(actions.repoError(RepoErrorType.GITHUB_RATE_LIMIT));\n    } else {\n      yield put(actions.repoError(RepoErrorType.RESPONSE_ERROR));\n    }\n  }\n}\n\n/**\n * Root saga manages watcher lifecycle\n */\nexport function* githubRepoFormSaga() {\n  // Watches for loadRepos actions and calls getRepos when one comes in.\n  // By using `takeLatest` only the result of the latest API call is applied.\n  // It returns task descriptor (just like fork) so we can continue execution\n  // It will be cancelled automatically on component unmount\n  yield takeLatest(actions.loadRepos.type, getRepos);\n}\n"]},"metadata":{},"sourceType":"module"}